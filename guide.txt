ESP32-WROOM-32D এর জন্য একটি পূর্ণাঙ্গ WiFi পেনিট্রেশন টেস্টিং ফার্মওয়্যার তৈরির বিস্তারিত প্রম্পট
ভূমিকা (Introduction)
উদ্দেশ্য (Purpose)
এই ডকুমেন্টটি ESP32-WROOM-32D (38-pin) ডেভেলপমেন্ট বোর্ডের জন্য একটি সম্পূর্ণ এবং উন্নত মানের ওয়াইফাই পেনিট্রেশন টেস্টিং ফার্মওয়্যার তৈরি করার জন্য একটি বিস্তারিত এবং বিশেষজ্ঞ-স্তরের প্রযুক্তিগত প্রম্পট হিসেবে কাজ করবে। এর মূল লক্ষ্য হলো এমন একটি টুল তৈরি করা যা একাধারে শক্তিশালী এবং শিক্ষামূলক, যা এমবেডেড সিস্টেম প্রোগ্রামিং এবং ওয়্যারলেস সিকিউরিটির উন্নত ধারণাগুলো প্রদর্শন করে। এই ফার্মওয়্যারটি শুধুমাত্র অনুমোদিত নিরাপত্তা নিরীক্ষা এবং শিক্ষাগত উদ্দেশ্যে ব্যবহারের জন্য ডিজাইন করা হয়েছে।
প্রযুক্তি স্ট্যাক (Technology Stack)
ফার্মওয়্যারটি সম্পূর্ণরূপে Espressif IoT Development Framework (ESP-IDF) এবং এর অন্তর্নিহিত FreeRTOS অপারেটিং সিস্টেম ব্যবহার করে তৈরি করতে হবে। কন্ট্রোল ইন্টারফেসটি হবে একটি আধুনিক, প্রতিক্রিয়াশীল সিঙ্গেল পেজ অ্যাপ্লিকেশন (SPA), যা ডিভাইস থেকে সরাসরি পরিবেশন করা হবে। এই আর্কিটেকচারটি ডিভাইসের সীমিত রিসোর্সের সর্বোত্তম ব্যবহার নিশ্চিত করবে এবং একটি মসৃণ ব্যবহারকারীর অভিজ্ঞতা প্রদান করবে।
নৈতিক ব্যবহার এবং সতর্কতা (Ethical Use and Warning)
এই ফার্মওয়্যারটি একটি শক্তিশালী টুল যা ওয়াইফাই নেটওয়ার্কের নিরাপত্তা দুর্বলতা পরীক্ষা করার জন্য ডিজাইন করা হয়েছে। এটি কঠোরভাবে শিক্ষাগত উদ্দেশ্যে এবং শুধুমাত্র সেই নেটওয়ার্কগুলিতে ব্যবহারের জন্য তৈরি করা উচিত যেখানে আপনার স্পষ্ট অনুমতি রয়েছে। অনুমতি ছাড়া কোনো নেটওয়ার্কের বিরুদ্ধে এই টুল ব্যবহার করা বেআইনি এবং অনৈতিক। এই প্রম্পটটি দায়িত্বশীল উন্নয়ন এবং নৈতিক ব্যবহারের উপর জোর দেয় । ব্যবহারকারীকে অবশ্যই স্থানীয় আইন মেনে চলতে হবে এবং এই টুলের কোনো অপব্যবহারের জন্য সম্পূর্ণ দায়ভার গ্রহণ করতে হবে।
অধ্যায় ১: প্রকল্পের ভিত্তি এবং স্থাপত্য (Chapter 1: Project Foundation and Architecture)
এই অধ্যায়ে ফার্মওয়্যারের স্থাপত্যের ভিত্তি স্থাপন করা হয়েছে, যা একটি মডুলার, পরিমাপযোগ্য এবং শক্তিশালী ডিজাইনের উপর দৃষ্টি নিবদ্ধ করে। এই ডিজাইনটি একই সাথে একাধিক কাজ ব্যর্থতা ছাড়াই পরিচালনা করতে সক্ষম হবে।
ESP-IDF প্রকল্পের কাঠামো (ESP-IDF Project Structure)
প্রকল্পটি একটি স্ট্যান্ডার্ড ESP-IDF কম্পোনেন্ট-ভিত্তিক কাঠামো অনুসরণ করবে, যা কোডের পুনঃব্যবহারযোগ্যতা এবং রক্ষণাবেক্ষণকে সহজ করে তোলে । এই মডুলার পদ্ধতি প্রতিটি কার্যকারিতাকে আলাদাভাবে ডেভেলপ এবং পরীক্ষা করার সুযোগ দেয়, যা জটিল সিস্টেমের জন্য অপরিহার্য ।
প্রকল্পের ডিরেক্টরি কাঠামোটি নিম্নরূপ হবে:
 * main/: এই কম্পোনেন্টে মূল অ্যাপ্লিকেশন লজিক, app_main ফাংশন এবং বিভিন্ন টাস্ক শুরু করার কোড থাকবে।
 * components/: এই ডিরেক্টরিতে কাস্টম এবং পুনঃব্যবহারযোগ্য মডিউলগুলো থাকবে।
   * web_server/: HTTP সার্ভার, DNS সার্ভার এবং ওয়েব ইন্টারফেসের জন্য সমস্ত API এন্ডপয়েন্ট পরিচালনার দায়িত্বে থাকবে এই কম্পোনেন্ট।
   * wifi_manager/: SoftAP সেটআপ, স্টেশন মোড কনফিগারেশন এবং ওয়াইফাই নেটওয়ার্ক স্ক্যানিং-এর মতো সমস্ত ওয়াইফাই-সম্পর্কিত কাজ পরিচালনা করবে।
   * attack_manager/: সমস্ত অ্যাটাক ভেক্টরের (Deauthentication, Handshake Capture, Evil Twin) মূল যুক্তি এবং অর্কেস্ট্রেশন এই কম্পোনেন্টে থাকবে।
   * filesystem_manager/: LittleFS ফাইল সিস্টেমের সমস্ত কার্যক্রমের জন্য একটি র‍্যাপার হিসেবে কাজ করবে, যা ফাইল অ্যাক্সেসকে সহজ করে তুলবে।
এই কাঠামোটি "সেপারেশন অফ কনসার্নস" নীতি অনুসরণ করে, যা কোডবেসকে পরিচালনা, ডিবাগ এবং প্রসারিত করা সহজ করে তোলে।
নির্ভরতা এবং কনফিগারেশন (Dependencies and Configuration)
প্রতিটি কম্পোনেন্টের নিজস্ব CMakeLists.txt ফাইল থাকবে যা তার নির্ভরতা এবং সোর্স ফাইলগুলো নির্দিষ্ট করবে।
 * CMakeLists.txt: প্রতিটি কম্পোনেন্টের জন্য idf_component_register নির্দেশিকা ব্যবহার করে পাবলিক (REQUIRES) এবং প্রাইভেট (PRIV_REQUIRES) নির্ভরতা স্পষ্টভাবে সংজ্ঞায়িত করতে হবে। উদাহরণস্বরূপ, attack_manager কম্পোনেন্টটি ব্যক্তিগতভাবে wifi_manager-এর উপর নির্ভরশীল হবে ।
 * sdkconfig Defaults: প্রকল্পের মূল কার্যকারিতার জন্য প্রয়োজনীয় কনফিগারেশনগুলো sdkconfig.defaults ফাইলে নির্দিষ্ট করতে হবে। এর মধ্যে রয়েছে CONFIG_LWIP_DNS_SUPPORT_MDNS_QUERIES (ক্যাপটিভ পোর্টালের জন্য), FreeRTOS-এর টিক রেট নির্ধারণ এবং প্রতিটি টাস্কের জন্য পর্যাপ্ত স্ট্যাক সাইজ বরাদ্দ করা।
FreeRTOS মাল্টিটাস্কিং আর্কিটেকচার (FreeRTOS Multitasking Architecture)
ফার্মওয়্যারের মূল স্থাপত্যটি FreeRTOS-এর প্রিemptive মাল্টিটাস্কিং ক্ষমতার উপর ভিত্তি করে তৈরি হবে, যা একটি নন-ব্লকিং এবং প্রতিক্রিয়াশীল সিস্টেম নিশ্চিত করে । একটি সিঙ্গেল-থ্রেডেড আর্কিটেকচার, যেমন আরডুইনোর loop() ফাংশন, দীর্ঘ সময় ধরে চলা অ্যাটাক (যেমন ডি-অথেন্টিকেশন ফ্লাড) চলাকালীন ওয়েব সার্ভারকে প্রতিক্রিয়াহীন করে তুলবে। তাই, একটি রিয়েল-টাইম অপারেটিং সিস্টেম (RTOS) ব্যবহার করা অপরিহার্য ।
 * টাস্ক সংজ্ঞা (Task Definitions):
   * web_server_task: উচ্চ অগ্রাধিকার সম্পন্ন টাস্ক। এটি HTTP এবং DNS সার্ভার পরিচালনা করবে এবং ব্যবহারকারীর ইন্টারফেস থেকে আসা অনুরোধের প্রতি সর্বদা প্রতিক্রিয়াশীল থাকবে।
   * wifi_scanner_task: মাঝারি অগ্রাধিকার সম্পন্ন টাস্ক। এটি প্রয়োজন অনুযায়ী নেটওয়ার্ক স্ক্যান করার জন্য চলবে এবং কাজ শেষে সাসপেন্ডেড থাকবে।
   * attack_manager_task: মাঝারি অগ্রাধিকার সম্পন্ন টাস্ক। এটি একটি অর্কেস্ট্রেটর হিসেবে কাজ করবে, যা একটি কমান্ড কিউ (Queue) থেকে নির্দেশ গ্রহণ করে নির্দিষ্ট অ্যাটাক সাব-টাস্ক চালু বা বন্ধ করবে।
   * deauth_task এবং sniffer_task: নিম্ন অগ্রাধিকার সম্পন্ন টাস্ক। এই ওয়ার্কার টাস্কগুলো একটানা প্যাকেট ইনজেকশন এবং স্নাইফিং-এর মতো রিসোর্স-ইনটেনসিভ কাজগুলো সম্পাদন করবে।
 * আন্তঃ-টাস্ক যোগাযোগ (Inter-Task Communication):
   * কমান্ড কিউ (Command Queue): web_server_task থেকে attack_manager_task-এ কমান্ড পাঠানোর জন্য একটি FreeRTOS কিউ ব্যবহার করা হবে। এটি ওয়েব ইন্টারফেসকে অ্যাটাক লজিক থেকে সম্পূর্ণরূপে বিচ্ছিন্ন (decouple) করে, যা সিস্টেমের স্থিতিশীলতা বাড়ায়।
   * ইভেন্ট গ্রুপ (Event Group): সিস্টেম-ব্যাপী অবস্থা (state) সংকেত দেওয়ার জন্য একটি FreeRTOS ইভেন্ট গ্রুপ ব্যবহার করা হবে। যেমন: WIFI_SCAN_COMPLETE, ATTACK_RUNNING, বা HANDSHAKE_CAPTURED।
এই মাল্টিটাস্কিং এবং ডিকাপলড আর্কিটেকচারটিই পুরো প্রকল্পটিকে ESP32-এর মতো একটি রিসোর্স-সীমাবদ্ধ ডিভাইসে স্থিতিশীল এবং কার্যকরভাবে চালানো সম্ভব করে তুলবে।
অধ্যায় ২: বেস সিস্টেম এবং ওয়েব ইন্টারফেস (Chapter 2: Base System and Web Interface)
এই অধ্যায়ে ব্যবহারকারীর সাথে সরাসরি মিথস্ক্রিয়া করা foundational উপাদানগুলির বিস্তারিত বর্ণনা দেওয়া হয়েছে।
SoftAP এবং নেটওয়ার্ক সেটআপ (SoftAP and Network Setup)
ফার্মওয়্যারটি বুট হওয়ার সাথে সাথে একটি ওয়াইফাই অ্যাক্সেস পয়েন্ট তৈরি করবে, যা কন্ট্রোল প্যানেল হোস্ট করবে।
 * ESP32-PENTEST নামে একটি SoftAP তৈরি করতে হবে। এর জন্য esp_wifi_init, esp_wifi_set_mode(WIFI_MODE_AP), এবং esp_wifi_set_config ফাংশন ব্যবহার করতে হবে ।
 * কন্ট্রোল প্যানেলটি যাতে সর্বদা 192.168.4.1 ঠিকানায় অ্যাক্সেসযোগ্য থাকে, তার জন্য SoftAP ইন্টারফেসের জন্য একটি স্ট্যাটিক আইপি ঠিকানা কনফিগার করতে হবে। এটি করার জন্য, ডিফল্ট DHCP সার্ভারটি প্রথমে বন্ধ করতে হবে, তারপর esp_netif_set_ip_info ব্যবহার করে স্ট্যাটিক আইপি (192.168.4.1), গেটওয়ে (192.168.4.1), এবং সাবনেট মাস্ক (255.255.255.0) সেট করতে হবে এবং সবশেষে DHCP সার্ভারটি পুনরায় চালু করতে হবে ।
ফাইল সিস্টেম এবং স্ট্যাটিক ফাইল পরিবেশন (File System and Static File Serving)
ওয়েব ইন্টারফেসের জন্য প্রয়োজনীয় HTML, CSS, এবং JavaScript ফাইলগুলো ডিভাইসের ফ্ল্যাশ মেমরিতে সংরক্ষণ করা হবে এবং সেখান থেকে পরিবেশন করা হবে।
 * LittleFS বনাম SPIFFS: ব্যবহারকারীর অনুরোধে SPIFFS উল্লেখ করা হলেও, এই প্রম্পটটি LittleFS ব্যবহারের জন্য দৃঢ়ভাবে সুপারিশ করছে। LittleFS ফরম্যাটিং এবং ফাইল লেখার ক্ষেত্রে উল্লেখযোগ্যভাবে দ্রুত, বিশেষ করে যখন পার্টিশন পূর্ণ হতে শুরু করে, যেখানে SPIFFS-এর পারফরম্যান্স মারাত্মকভাবে হ্রাস পায় । এছাড়াও, LittleFS পাওয়ার-ফেলিওর বা আকস্মিক রিবুটের ক্ষেত্রে ডেটা করাপশনের বিরুদ্ধে অনেক বেশি শক্তিশালী, যা একটি এমবেডেড ডিভাইসের জন্য অত্যন্ত গুরুত্বপূর্ণ একটি বৈশিষ্ট্য । এই প্রকৌশলগত সিদ্ধান্তটি টুলের ওয়েব পেজ লোডের সময় এবং সামগ্রিক নির্ভরযোগ্যতাকে সরাসরি প্রভাবিত করবে।
 * বাস্তবায়ন: একটি কাস্টম পার্টিশন টেবিল (partitions.csv) তৈরি করতে হবে যেখানে storage নামে একটি LittleFS পার্টিশন থাকবে। ফার্মওয়্যারের শুরুতে esp_vfs_littlefs_register ফাংশন ব্যবহার করে এই পার্টিশনটি মাউন্ট করতে হবে। এরপর esp_http_server ব্যবহার করে এমন হ্যান্ডলার তৈরি করতে হবে যা / (index.html), /style.css, এবং /script.js-এর মতো অনুরোধের জন্য মাউন্ট করা ফাইল সিস্টেম থেকে সংশ্লিষ্ট ফাইল পড়ে ক্লায়েন্টকে পরিবেশন করবে ।
API এন্ডপয়েন্ট ডিজাইন (API Endpoint Design)
ফার্মওয়্যারের C ব্যাকএন্ড এবং JavaScript ফ্রন্টএন্ডের মধ্যে একটি পরিষ্কার এবং কাঠামোবদ্ধ যোগাযোগের জন্য একটি RESTful API ডিজাইন করতে হবে। এই API একটি চুক্তি (contract) হিসেবে কাজ করবে, যা উভয় দিকের ডেভেলপমেন্টকে সমান্তরাল এবং অনুমানযোগ্য করে তুলবে।
সারণী ২.১: কোর API এন্ডপয়েন্ট সংজ্ঞা
| এন্ডপয়েন্ট | মেথড | বর্ণনা | অনুরোধের বডি (JSON) | প্রতিক্রিয়ার বডি (JSON) |
|---|---|---|---|---|
| /api/scan | GET | একটি ওয়াইফাই স্ক্যান শুরু করে এবং উপলব্ধ নেটওয়ার্কগুলোর একটি তালিকা প্রদান করে। | null | [{"ssid": "...", "bssid": "...", "rssi": -55, "channel": 6},...] |
| /api/target | POST | পরবর্তী আক্রমণের জন্য টার্গেট নেটওয়ার্ক সেট করে। | {"bssid": "...", "channel": 6} | {"status": "ok", "message": "Target set"} |
| /api/attack | POST | একটি নির্দিষ্ট আক্রমণ শুরু বা বন্ধ করে। | {"attack": "deauth_broadcast", "action": "start"} | {"status": "ok", "message": "Attack started"} |
| /api/status | GET | ডিভাইসের বর্তমান অবস্থা (idle, scanning, attacking, handshake captured) এবং ক্যাপচার করা ডেটা পুনরুদ্ধার করে। | null | {"status": "attacking", "attack_type": "handshake_capture", "target_bssid": "...", "captured_password": null} |
| /download/handshake.pcap | GET | ক্যাপচার করা হ্যান্ডশেক প্যাকেট ফাইলটি ডাউনলোড করার সুযোগ দেয়। | null | (বাইনারি ফাইল ডেটা, Content-Type: application/octet-stream) |
অধ্যায় ৩: অ্যাটাক মডিউলগুলির বিস্তারিত বাস্তবায়ন (Chapter 3: Detailed Implementation of Attack Modules)
এই অধ্যায়টি প্রম্পটের প্রযুক্তিগত কেন্দ্রবিন্দু, যেখানে নিম্ন-স্তরের প্যাকেট ম্যানিপুলেশন এবং অ্যাটাক ভেক্টরগুলোর বাস্তবায়নের বিস্তারিত বর্ণনা দেওয়া হয়েছে।
Deauthentication অ্যাটাক (Deauthentication Attack)
এই মডিউলটি টার্গেট নেটওয়ার্কের সাথে সংযুক্ত সমস্ত ক্লায়েন্টকে একযোগে সংযোগ বিচ্ছিন্ন করার জন্য ডিজাইন করা হয়েছে।
 * ESP-IDF সীমাবদ্ধতা বাইপাস: স্ট্যান্ডার্ড ESP-IDF বিল্ডগুলো দূষিত ম্যানেজমেন্ট ফ্রেম (যেমন deauthentication) ইনজেক্ট করা থেকে বিরত রাখে । এই সীমাবদ্ধতা অতিক্রম করার জন্য, ESP32 নিরাপত্তা গবেষণা কমিউনিটির আবিষ্কৃত একটি কৌশল প্রয়োগ করতে হবে। নিম্নলিখিত ফাংশনটি কোডে যোগ করতে হবে, যা ESP-IDF-এর অভ্যন্তরীণ নিরাপত্তা পরীক্ষাকে বাইপাস করে :
   extern "C" int ieee80211_raw_frame_sanity_check(int32_t arg, int32_t arg2, int32_t arg3){
    return 0; // Always return 0 to bypass the check
}

   এই ফাংশন ওভাররাইডকে সফলভাবে কম্পাইল করার জন্য, প্রকল্পের CMakeLists.txt ফাইলে লিঙ্কার ফ্ল্যাগ হিসেবে -zmuldefs যোগ করতে হবে ।
 * 802.11 ফ্রেম নির্মাণ: একটি C struct ব্যবহার করে 802.11 deauthentication ফ্রেমের কাঠামো তৈরি করতে হবে। এই কাঠামোতে Frame Control, Duration, Destination MAC, Source MAC, BSSID, এবং Reason Code ফিল্ডগুলো অন্তর্ভুক্ত থাকবে ।
   typedef struct {
    uint16_t frame_control;
    uint16_t duration;
    uint8_t dest_addr[span_0](start_span)[span_0](end_span);
    uint8_t source_addr[span_1](start_span)[span_1](end_span);
    uint8_t bssid[span_2](start_span)[span_2](end_span);
    uint16_t seq_ctrl;
    uint16_t reason_code;
} deauth_frame_t;

 * ফ্রেম ইনজেকশন লজিক: এই যুক্তিটি একটি নিবেদিত FreeRTOS টাস্ক (deauth_task)-এর মধ্যে থাকবে। টাস্কটি একটি লুপে চলবে, যেখানে এটি deauthentication ফ্রেম তৈরি করবে। ব্রডকাস্ট আক্রমণের জন্য, Destination MAC হবে FF:FF:FF:FF:FF:FF, এবং Source MAC ও BSSID হবে টার্গেট অ্যাক্সেস পয়েন্টের MAC ঠিকানা। এরপর esp_wifi_internal_tx(WIFI_IF_AP, &deauth_frame, sizeof(deauth_frame)) ফাংশনটি ব্যবহার করে প্যাকেটটি বাতাসে ইনজেক্ট করা হবে ।
হ্যান্ডশেক ক্যাপচার (Handshake Capture)
এই মডিউলটি একটি স্বয়ংক্রিয় প্রক্রিয়ার মাধ্যমে WPA/WPA2 4-ওয়ে হ্যান্ডশেক ক্যাপচার করার জন্য ডিজাইন করা হয়েছে।
 * প্রমিসকিউয়াস মোড এবং প্যাকেট স্নাইফিং: প্যাকেট ক্যাপচার করার জন্য, ESP32-এর ওয়াইফাই ইন্টারফেসকে প্রমিসকিউয়াস মোডে সেট করতে হবে। এর জন্য esp_wifi_set_promiscuous(true) ফাংশনটি কল করতে হবে। এরপর esp_wifi_set_channel() ব্যবহার করে টার্গেট নেটওয়ার্কের চ্যানেলে সুইচ করতে হবে এবং esp_wifi_set_promiscuous_rx_cb() দিয়ে একটি স্নাইফার কলব্যাক ফাংশন নিবন্ধন করতে হবে ।
 * EAPOL প্যাকেট শনাক্তকরণ: স্নাইফার কলব্যাক ফাংশনটি একটি কাঁচা বাইট বাফার গ্রহণ করে। WPA/WPA2 হ্যান্ডশেক গঠনকারী EAPOL প্যাকেটগুলো শনাক্ত করার জন্য এই বাফারটিকে পার্স করতে হবে। প্রক্রিয়াটি নিম্নরূপ:
   * প্রাপ্ত বাফারটিকে wifi_promiscuous_pkt_t স্ট্রাকচারে কাস্ট করতে হবে, যা মেটাডেটা (rx_ctrl) এবং মূল প্যাকেট পেলোড (payload) ধারণ করে ।
   * এই পেলোডটি হলো একটি পূর্ণাঙ্গ 802.11 ফ্রেম। এর MAC হেডার পার্স করে ফ্রেমের ধরন পরীক্ষা করতে হবে। হ্যান্ডশেক প্যাকেটগুলো Data বা QoS Data ফ্রেমের মধ্যে থাকে ।
   * Data ফ্রেমের পেলোড সরাসরি আইপি প্যাকেট নয়; এটি একটি LLC/SNAP হেডার দ্বারা আবৃত থাকে। এই হেডারের মধ্যে EtherType ফিল্ডটি থাকে ।
   * EAPOL প্যাকেট শনাক্ত করার জন্য EtherType ফিল্ডের মান 0x888e কিনা তা পরীক্ষা করতে হবে ।
     এই বহু-স্তরীয় পার্সিং প্রক্রিয়াটি নির্ভুলভাবে শুধুমাত্র প্রয়োজনীয় হ্যান্ডশেক প্যাকেটগুলো ক্যাপচার এবং সংরক্ষণ নিশ্চিত করে।
 * PCAP ফাইল ফরম্যাটিং: ক্যাপচার করা EAPOL প্যাকেটগুলো একটি বাফারে সংরক্ষণ করতে হবে। ব্যবহারকারী যখন ফাইলটি ডাউনলোড করার অনুরোধ করবে, তখন ফার্মওয়্যারকে অবশ্যই একটি বৈধ PCAP ফাইল তৈরি করতে হবে। এর জন্য, সংরক্ষিত প্যাকেট ডেটার শুরুতে একটি PCAP গ্লোবাল হেডার এবং প্রতিটি প্যাকেটের আগে একটি PCAP রেকর্ড হেডার যুক্ত করতে হবে। এই হেডারগুলোর জন্য C struct সংজ্ঞায়িত করতে হবে, যা PCAP ফাইল ফরম্যাট স্পেসিফিকেশন অনুসরণ করবে । এটি নিশ্চিত করবে যে ডাউনলোড করা ফাইলটি Wireshark-এর মতো টুল দিয়ে সরাসরি খোলা যাবে।
Evil Twin এবং ক্যাপটিভ পোর্টাল (Evil Twin and Captive Portal)
এই মডিউলটি একটি উন্নত সামাজিক প্রকৌশল আক্রমণ চালায়, যেখানে ব্যবহারকারীকে নকল নেটওয়ার্কে সংযুক্ত করে পাসওয়ার্ড হাতিয়ে নেওয়া হয়।
 * অ্যাটাক অর্কেস্ট্রেশন: attack_manager_task নিম্নলিখিত ক্রমানুসারে আক্রমণটি পরিচালনা করবে:
   * টার্গেট করা আসল অ্যাক্সেস পয়েন্টের ক্লায়েন্টদের সংযোগ বিচ্ছিন্ন করার জন্য deauth_task শুরু করবে।
   * প্রাথমিক ESP32-PENTEST SoftAP বন্ধ করবে।
   * টার্গেট নেটওয়ার্কের হুবহু একই SSID এবং চ্যানেল ব্যবহার করে একটি নতুন SoftAP চালু করবে ।
   * ক্যাপটিভ পোর্টাল কার্যকারিতার জন্য DNS এবং HTTP সার্ভার চালু করবে।
 * DNS এবং HTTP সার্ভার: ক্যাপটিভ পোর্টালের মূল ভিত্তি হলো DNS হাইজ্যাকিং। যখন কোনো আধুনিক ডিভাইস (যেমন অ্যান্ড্রয়েড বা আইওএস) একটি নতুন ওয়াইফাই নেটওয়ার্কে সংযুক্ত হয়, তখন এটি connectivitycheck.gstatic.com-এর মতো একটি পরিচিত URL অ্যাক্সেস করে ইন্টারনেট সংযোগ পরীক্ষা করে ।
   * DNS Hijack: ESP32-কে একটি DNS সার্ভার চালাতে হবে যা যেকোনো ডোমেইনের জন্য আসা সমস্ত DNS কোয়েরির উত্তরে নিজের আইপি ঠিকানা (192.168.4.1) পাঠাবে। এটি ডিভাইসকে বিশ্বাস করায় যে সে একটি ক্যাপটিভ পোর্টালের পিছনে রয়েছে এবং লগইন করার জন্য একটি পপ-আপ ব্রাউজার চালু করে ।
   * HTTP Redirect: এরপর, যখন ডিভাইসটি আসল URL-এর জন্য একটি HTTP অনুরোধ পাঠায়, তখন ESP32-এর HTTP সার্ভারটি সেই অনুরোধটি গ্রহণ করে এবং প্রতিক্রিয়া হিসেবে ক্যাপটিভ পোর্টালের লগইন পেজের HTML কোডটি পাঠিয়ে দেয় ।
 * পাসওয়ার্ড ক্যাপচার এবং অ্যাটাক সমাপ্তি: ক্যাপটিভ পোর্টালের HTML পেজে একটি ফর্ম থাকবে যা ব্যবহারকারীর কাছ থেকে পাসওয়ার্ড ইনপুট নেবে এবং /api/login এন্ডপয়েন্টে POST অনুরোধের মাধ্যমে জমা দেবে। এই অনুরোধটি পাওয়ার পর, ফার্মওয়্যারটি:
   * প্রাপ্ত পাসওয়ার্ডটি একটি গ্লোবাল ভ্যারিয়েবলে সংরক্ষণ করবে।
   * deauth_task এবং Evil Twin SoftAP উভয়ই বন্ধ করবে।
   * আসল ESP32-PENTEST কন্ট্রোল নেটওয়ার্কটি পুনরায় চালু করবে।
   * ব্যবহারকারী কন্ট্রোল নেটওয়ার্কে পুনরায় সংযোগ করলে, ওয়েব ইন্টারফেস /api/status এন্ডপয়েন্টের মাধ্যমে ক্যাপচার করা পাসওয়ার্ডটি প্রদর্শন করবে।
অধ্যায় ৪: ফ্রন্টএন্ড এবং ব্যবহারকারীর অভিজ্ঞতা (Chapter 4: Frontend and User Experience)
এই অধ্যায়ে একটি কার্যকরী এবং ব্যবহারকারী-বান্ধব কন্ট্রোল প্যানেল তৈরির উপর আলোকপাত করা হয়েছে।
UI ডিজাইন এবং লেআউট (UI Design and Layout)
index.html ফাইলের জন্য একটি সহজ, পরিষ্কার এবং প্রতিক্রিয়াশীল লেআউট ডিজাইন করতে হবে। এতে নিম্নলিখিত বিভাগগুলো থাকবে:
 * ওয়াইফাই স্ক্যান ফলাফল: একটি টেবিল যেখানে SSID, BSSID, RSSI এবং চ্যানেল নম্বরসহ কাছাকাছি নেটওয়ার্কগুলো প্রদর্শিত হবে।
 * টার্গেট তথ্য: বর্তমানে নির্বাচিত টার্গেটের বিবরণ প্রদর্শনের জন্য একটি বিভাগ।
 * অ্যাটাক কন্ট্রোল প্যানেল: প্রতিটি আক্রমণের জন্য আলাদা আলাদা প্যানেল, যেখানে "Start" এবং "Stop" বাটন থাকবে।
 * স্ট্যাটাস এবং ফলাফল: ডিভাইসের বর্তমান অবস্থা (যেমন, "Attacking", "Idle") এবং ক্যাপচার করা কোনো তথ্য (যেমন, হ্যান্ডশেক স্ট্যাটাস বা চুরি করা পাসওয়ার্ড) প্রদর্শনের জন্য একটি এলাকা।
 * ডাউনলোড লিঙ্ক: হ্যান্ডশেক সফলভাবে ক্যাপচার হওয়ার পরেই .pcap ফাইল ডাউনলোডের জন্য একটি লিঙ্ক দৃশ্যমান হবে।
JavaScript লজিক এবং স্টেট ম্যানেজমেন্ট (JavaScript Logic and State Management)
ওয়েব ইন্টারফেসের সমস্ত কার্যকারিতা JavaScript দ্বারা চালিত হবে, যা একটি গতিশীল এবং ইন্টারেক্টিভ অভিজ্ঞতা প্রদান করবে।
 * অ্যাসিঙ্ক্রোনাস কমিউনিকেশন: ESP32-এর সাথে সমস্ত যোগাযোগ fetch API ব্যবহার করে অ্যাসিঙ্ক্রোনাসভাবে করা হবে, যা সারণী ২.১-এ সংজ্ঞায়িত এন্ডপয়েন্টগুলোকে কল করবে।
 * localStorage ব্যবহার করে স্টেট পারসিস্টেন্স: ব্যবহারকারীর অভিজ্ঞতা উন্নত করার জন্য, ব্রাউজারের localStorage ব্যবহার করে বর্তমান অবস্থা, যেমন নির্বাচিত টার্গেট BSSID, সংরক্ষণ করা হবে। এর ফলে ব্যবহারকারী যদি ভুলবশত পৃষ্ঠাটি রিফ্রেশ করে ফেলে, তাহলেও তাকে পুনরায় টার্গেট নির্বাচন করতে হবে না ।
 * স্বয়ংক্রিয় পুনঃসংযোগ যুক্তি (Self-Healing UI): Evil Twin আক্রমণের মতো কার্যকারিতা চালানোর সময় ESP32-এর নেটওয়ার্ক কনফিগারেশন পরিবর্তন হয়, যার ফলে ব্যবহারকারীর ব্রাউজার সাময়িকভাবে সংযোগ বিচ্ছিন্ন হয়ে যায় । একটি সাধারণ ওয়েব পেজ এক্ষেত্রে একটি "Connection Lost" ত্রুটি দেখাবে। এই সমস্যা সমাধানের জন্য, একটি স্বয়ংক্রিয় পুনঃসংযোগ ব্যবস্থা বাস্তবায়ন করতে হবে।
   * একটি JavaScript ফাংশন setInterval ব্যবহার করে পর্যায়ক্রমে /api/status এন্ডপয়েন্ট পোল করবে ।
   * যদি fetch অনুরোধটি ব্যর্থ হয় (যেমন, .catch() ব্লকে প্রবেশ করে), UI বুঝতে পারবে যে সার্ভার অফলাইন এবং একটি "Reconnecting..." বার্তা প্রদর্শন করবে।
   * যখন একটি fetch অনুরোধ সফল হয়, তার মানে হলো ESP32 পুনরায় অনলাইনে এসেছে (হয় রিবুট হয়েছে অথবা আক্রমণ শেষ করে মূল AP পুনরুদ্ধার করেছে)। তখন স্ক্রিপ্টটি window.location.reload() কল করে পৃষ্ঠাটি রিফ্রেশ করবে, যা একটি পরিষ্কার এবং নতুন অবস্থায় সংযোগ পুনঃস্থাপন করবে। এই "সেলফ-হিলিং" ইন্টারফেসটি টুলের ব্যবহারযোগ্যতাকে উল্লেখযোগ্যভাবে উন্নত করে।
